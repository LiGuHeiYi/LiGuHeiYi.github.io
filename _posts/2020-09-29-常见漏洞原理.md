---
layout: post
title: 常见漏洞原理
date: 2020-9-29
categories: blog
tags: [CTF,web]
description: 挖挖挖
---
[TOC]



# 常见web漏洞

## SQL注入 

SQL注入是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令de web攻击方式。

由于WEB开发人员几乎不可能对所有输入进行检测，所以SQL注入漏洞几乎是最常见，最广泛的漏洞类型

> 按照注入点类型来分类

### （1）数字型注入点

许多网页链接有类似的结构 http://xxx.com/users.php?id=1 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。

这一类的 SQL 语句原型大概为 `select * from 表名 where id=1 ` 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：`select * from 表名 where id=1 and 1=1`

### （2）字符型注入点

网页链接有类似的结构 http://xxx.com/users.php?name=admin 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 `select * from 表名 where name='admin'` 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。

若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：`select * from 表名 where name='admin' and 1=1 '` 我们需要将这些烦人的引号给处理掉。

### （3）搜索型注入点

这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 `"keyword=关键字"` 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。

此类注入点提交的 SQL 语句，其原形大致为：`select * from 表名 where 字段 like '%关键字%'` 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：`select * from 表名 where 字段 like '%测试%' and '%1%'='%1%'`

> 按照数据提交的方式来分类

### （1）GET 注入

提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接http://xxx.com/index.php?id=1 , id 是注入点。

### （2）POST 注入

使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。

### （3）Cookie 注入

HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。

### （4）HTTP 头部注入

注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。

> 按照执行效果来分类

### （1）基于布尔的盲注

即可以根据返回页面判断条件真假的注入。

### （2）基于时间的盲注

即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。

### （3）基于报错注入

即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。

1. 单引号
2. 双引号
3. 基于数字型注入

### （4）联合查询注入

可以使用union的情况下的注入。

### （5）堆查询注入

可以同时执行多条语句的执行时的注入。

### （6）宽字节注入

宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）

### 基于sqli-labs的实践操作

#### 1.基于报错的GET sql注入

##### less-1

![](\img\less-1.png)

提示说输入一个数字作为ID的值

那么先在url输入?id=1

![](\img\less-1输入id=1.png)

显示查询成功，返回了用户Dumb

然后尝试使其报错，输入 ?id=1'

![](\img\less-1输入id-1'.png)

报错了，显示为 ''1'' LIMIT 0,1'

有了这个，我们就可以揣测一下网站后端的sql请求语句了

首先，这个报错语句是被 ' ' 单引号闭合的，于是将其拆分 '   '1'' LIMIT 0,1   '，可知报错的段落是 '1'' LIMIT 0,1,由于我们输入的id值是1'

,所以再拆分一下为'   1'   ' LIMIT 0,1

由此可以看出后台语句大致是 "SELECT username,password FROM user WHERE id = 'id' limit 0,1 " ，id被单引号包裹，这是字符型注入点

##### less-2

![](\img\less-2.png)

流程与上面差不多

不同的是，这次输入id=1'后报错为 '' LIMIT 0,1'

还是用和上面一样的方法拆分这段 ，'     ' LIMIT 0,1      '  -->' LIMIT 0,1

可以看到limit前面多了一个单引号，而我们正是在1后面多加了一个单引号，说明这个单引号并没有被id读进去

由此可以看出后台语句大致是 "SELECT username,password FROM user WHERE id = id limit 0,1 "，id没有被单引号包裹，这是一个数字型注入点

##### less-3

![](\img\less-3.png)

这次的报错是 ''1'') LIMIT 0,1'

拆分 '   '1'') LIMIT 0,1   '-->'1'') LIMIT 0,1-->'   *1'*   ') LIMIT 0,1

显然，后台语句是"SELECT username,password FROM user WHERE id = ('id') limit 0,1 "

但上面的语句只不过都是猜测，怎么验证呢，只有再构造语句来验证了

比如上面这个less-3

我们试着把输入改为 id=1') --+或id=1') --%20

![](\img\--+.png)

![](\img\--%20.png)

都成功了，这就说明后台语句和我们想的八九不离十了

##### less-4

这次除了使用注释符，用上面的方法怎么输入页面都不报错，而题目说了 Double quotes,显然这次id是被""包裹了，输入的id值都会被当作字符串，加单引号括号都没用。

那就使用\来制造报错，输入 id=1\

返回报错 '"1\\") LIMIT 0,1'-->"1\\") LIMIT 0,1

\将后面的双引号消掉了，于是这一段语句就闭合不了了，遂报错

合理推测："SELECT username,password FROM user WHERE id = ("id") limit 0,1 "

验证：

![](\img\less-4.png)

这样4种不同的注入点的后台语句就通过报错大致的试出来了

之后就可以根据注入点类型通过order by语句测试字段数，通过union语句爆出表名，字段名等

例如less-1(字符型) 就可以输入?id=1' order by 1(,2,3,4... ) --+测出该表中column的数量，order by最多能够到几，表中就有几段column，这对之后union注入有大用

less-1能够order by到3，也就是它有3个字段，于是接下来union注入

我们要构造的语句是SELECT username,password FROM user WHERE id = '0' union select 1,2,3 --+ limit 0,1

所以输入（如果利用hackerbar或max hackerbar工具会方便很多）：id=0' union select 1,2,3 --+

这里构造id=0的目的就是让这一段请求报错，这样页面上显示的才是union联合语句查找出来的结果

效果

![](\img\union注入.png)

可以看到，我们select 1,2,3 ，它回显了2，3，说明返回的是三个字段中的第二个和第三个，这对接下来爆表和爆库有用

于是接下来注入 id=0' union select 1,user(),database() --+

![](\img\union爆库.png)

爆出了用户名和使用的数据库名

然后还可以用version()函数爆出数据库版本，这样就可以针对性的进行一些注入

例如：

爆表：id=0' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema=database() --+			information_schema是储存了所有数据库信息的库，tables储存了所有表信息的表

![](\img\union爆表.png)

看到了最后一个表是'users',可用于下一步爆字段

爆字段：id=0' union select 1,group_concat(column_name),database() from information_schema.columns where table_name='users' --+

![](\img\union爆字段.png)

爆出来了users表中的所有字段，最重要的user,password等全出来了，接下来就可以union查询出它们的值了

id=0' union select 1,group_concat(username,0x3a,password),3 from users --+

![](img\union爆出账号密码.png)

好家伙，借助group_concat()方法，该数据库所有的账号密码都以“账号：密码”的格式爆出来了

## 任意文件包含 

网站服务器配置中的allow_url_fopen以及allow_url_include对文件包含的实现影响很大

最常用的方式是在页面可以包含文件的情况下，用file://(本地文件包含) ,php://filter(input, memory,temp) ,data:// ,zip://系列 ,http://(远程文件包含)还有phar:// 等伪协议进行文件包含，进行getshell等操作

## XSS跨站请求 

### 反射型(reflect)

还没彻底整明白，以后再水

### 储存型(store)

还没彻底整明白，以后再水

### DOM型

上次招新赛就是DOM型，传入的username参数会被嵌入到返回页面的DOM中，直接嵌入

```HTML
<script>alert(document.cookie)</script>
```

直接弹出cookie

## 文件上传

重要基础知识

```
当客户端提交后，收到上传文件的页面获得了一个$_FILES 数组 

$_FILES数组内容如下: 
$_FILES['myFile']['name'] 客户端文件的原名称。 
$_FILES['myFile']['type'] 文件的 MIME 类型，需要浏览器提供该信息的支持。 
$_FILES['myFile']['size'] 已上传文件的大小，单位为字节。 
$_FILES['myFile']['tmp_name'] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。 
$_FILES['myFile']['error'] 和该文件上传相关的错误代码。['error'] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) 
UPLOAD_ERR_OK 
值：0; 没有错误发生，文件上传成功。 
UPLOAD_ERR_INI_SIZE 
值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 
UPLOAD_ERR_FORM_SIZE 
值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 
UPLOAD_ERR_PARTIAL 
值：3; 文件只有部分被上传。 
UPLOAD_ERR_NO_FILE 
值：4; 没有文件被上传。 
值：5; 上传文件大小为0. 

文件被上传结束后，默认地被存储在了临时目录中，这时您必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。也就是不管是否上传成功，脚本执行完后临时目录里的文件肯定会被删除。所以在删除之前要用PHP的 copy() 函数将它复制到其它位置，此时，才算完成了上传文件过程。
```

