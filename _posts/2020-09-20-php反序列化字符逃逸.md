---
layout: post
title: php反序列化字符逃逸
date: 2020-9-21
categories: blog
tags: [CTF,php字符反序列化]
description: 我好想逃，却逃不掉
---



# PHP反序列化字符逃逸



读题目源码的时候，一旦看到"serialize()"和"replace"(比如str_replace(),preg_replace()等)，就基本可以开始往反序列化逃逸的方向考虑了
反序列化字符逃逸都大同小异，基本可以分为“替换后字符串变长”和“替换后字符串变短的

其核心原理都是利用替换后变长或变短的字符串“顶出”后一个属性并将payload替换进去，或“吞并”后一个属性值的一部分，使我们在后一个属性中构建的payload成为我们想要的属性
## 替换之后字符串变长
示例代码:

```php
<?php
function filter($str){
    return str_replace('bb', 'ccc', $str);
}
class A{
    public $name='aaaa';
    public $pass='123456';
}
$AA=new A();
echo serialize($AA)."\n";
$res=filter(serialize($AA));

$c=unserialize($res);
echo $c->pass;
?>
```

上面这段代码中的filter()函数，会将传入的字符串 $str 中的'bb'替换为'ccc'，替换后字符串变长

其后对$AA进行序列化然后调用了这个filter函数并反序列化输出，这就构成了一个反序列化字符逃逸漏洞

如果这时我们有办法构造payload更改$AA中的内容，便可以利用这个漏洞，因为只要$name或$pass属性中每多一对'bb'字符，便会使之后的$res中字符多一个

而unserialize函数读取序列化字符串时，是通过s:所指定的长度和;"}来判断一个属性的结束的，这二者缺一不可，如果没有s所指定的长度，unserialize()就会在读到;"}时结束一个属性的读取，也就是如果属性的值中有;"}，就可以直接“骗”过它，让它认为这段字符串结束了，但一般来说，s指定了字符串的长度让它不会轻易“受骗”。

但filter函数给了我们一个“戏弄”它的机会，因为每个'bb'字符串都会使最终的字符串长度多一位，让实际的字符串比s所记录的长一位。仅仅只长一位没什么，php会报错，但如果在'bb'字符串后面的内容是";}呢？如果name的内容是"bbbbbb";}",则序列化后，s的值为9，在被filter函数过滤后为"ccccccccc";}",那么因为s为9，unserialize函数只会读到最后一个'c'处,由于后面是;"}，它便会认为这串字符结束了。

这便是反序列化字符逃逸的基本原理了，利用这种方式，我们就能任意构造name属性后面的内容，比如更改pass的内容，甚至添加一个“本不应该存在的属性”。如：构造name=“bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";s:4:"pass";s:11:"Hello,world";}“, 这里面有33个'bb', 紧跟其后的";s:11:"Hello,world";}也是33个字符，这样经过filter函数替换后,多出来的33个'c'会“顶”掉后面的";s:4:"pass";s:11:"Hello,world";}，并使后者被当作pass属性读入，这样，最终name的值为33个'ccc'，而pass的值就变为Hello,world

## 替换后字符变短

这种情况和上面那种大同小异，核心原理都是一样的，“替换后字符串长度改变，在字符串中构造payload”。唯一不同的大概是，上面这种payload构造在被替换的字符串里面，这种的payload构造在下一个属性的字符串里面

```php
<?php
function filter($str){
    return str_replace('bbb', 'cc', $str);
}
class A{
    public $name='aaaa';
    public $pass='123456';
}
$AA=new A();
echo serialize($AA)."\n";
$res=filter(serialize($AA));

$c=unserialize($res);
echo $c->pass;
?>
```

还是这串代码，不同的地方仅仅是从用'ccc'替换'bb'变成了用'cc'替换'bbb' 

这时，构造name=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,pass=123456";s:5:"pass2";s:5:"Hello";}

这里面有24个'bbb'，经过filter后会缩短24个字符，刚好可以包裹 ";s:4:"pass";s:6:"123456 这一段，于是后一段";s:5:"pass2";s:5:"Hello";}就被当作另一个属性被读进去了，这样我们又能更改本来不能更改的属性的内容甚至添加属性了

反序列化字符逃逸的应用条件十分苛刻，一般只有比赛的时候用的上，但终归是一种漏洞，其基本原理就在这里了